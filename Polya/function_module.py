from classes import *
from heuristic import *
from itertools import product, ifilter
from inspect import getargspec

# Represents the conclusion of a Function_restriction.    
class Function_conclusion:
    
    # lterm, rterm are lambda functions with the same arguments that are expected to return Terms.
    # their first arguments must be a Heuristic_data
    # comp is GE,GT,LE,LT
    def __init__(self, lterm, rterm, comp):
        self.lterm = lterm
        self.rterm = rterm
        self.comp = comp
        
    def __str__(self):
        return str(self.lterm) + " " + comp_str[self.comp] + " " + str(self.rterm)
        
    # ivars is a tuple of IVars with len(ivars) equal to the number of free variables in lterm and rterm
    # H is a Heuristic_data
    # This function computes the term_ or zero_comparison generated by plugging in ivars to lterm and rterm
    # and sends it to H.
    def learn_term_comparison(self, ivars, H):
        left = self.lterm(H, *ivars)
        right = self.rterm(H, *ivars)
        comp = self.comp
        
        if isinstance(left, IVar):
            i = left.index
        elif left == 0:
            self.learn_zero_comparison(right, comp_reverse(comp), H)
            return
        else:
            i = H.get_index_of_name_def(left)
            if not i:
                return 
            
        if isinstance(right, IVar):
            j = right.index
        elif right == 0:
            self.learn_zero_comparison(left, comp, H)
            return
        else:
            j = H.get_index_of_name_def(right)
            if not j:
                return
            
        H.learn_term_comparison(i, j, comp, 1, FUN)
        
        
    def learn_zero_comparison(self, term, comp, H):
        if isinstance(term, IVar):
            H.learn_zero_comparison(term.index, comp, FUN)
        else:
            i = H.get_index_of_name_def(term)
            if i:
                H.learn_zero_comparison(i, comp, FUN)

# This is the main class used to pass information about a function.
class Function_restriction:
    # name is a string, only used to identify this piece of info: ie, "monotonicity of exp"
    # hypotheses is a lambda predicate whose first argument is a Heuristic_data
    # conclusion is a Function_conclusion whose lterm and rterm have the same arguments as hypotheses
    # For all {free_vars} in {a0,a1,...,an}, [hypotheses({freevars})] => conclusion({freevars})
    def __init__(self, name, hypotheses, conclusion):
        self.name = name
        hargs, clargs, crargs = getargspec(hypotheses).args, getargspec(conclusion.lterm).args, getargspec(conclusion.rterm).args
        if hargs != clargs or hargs != crargs:
            raise Exception("Bad conclusion arguments!")
        self.hypotheses = hypotheses
        self.conclusion = conclusion
        
    def __str__(self):
        # return 'Function name: '+self.name+'. For all '+str(self.free_vars)+'('+str(self.hypotheses)+'=>'+str(self.conclusion)+')'
        return self.name

# used to generate all k_tuples of IVars  in range(0,n)    
def generate_tuples(n, k):
    ivs = [IVar(i) for i in range(n + 1)]
    return product(ivs, repeat=k)  # This returns an iterator
    
    
    
def learn_func_comparisons(H):
            
    # Iterates through all tuples of IVars that satisfy the hypotheses of restr
    # and learns of them the conclusion of restr
    # restr is a Function_restriction
    def learn_from_function_restriction(restr):
        hyp = restr.hypotheses
        num_vars = len(getargspec(hyp).args) - 1
        num_defs = H.num_terms
        iterator = generate_tuples(num_defs, num_vars)
        conclusion = restr.conclusion
        
        for c in ifilter(lambda t: hyp(H, *t), iterator):  # c is an ordered tuple of IVars that satisfies hyp
            conclusion.learn_term_comparison(c, H)
            
        
    if H.verbose:   
        print 'Learning functional facts...'
    restrictions = H.function_information
    for r in restrictions:
        if H.verbose:
            print 
            print 'From the restriction', r, 'we can learn:'
        learn_from_function_restriction(r)
    if H.verbose:
        print
